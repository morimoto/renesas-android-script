From 2b8c584cad0fecf41cdd80a9ddd599613a7911bf Mon Sep 17 00:00:00 2001
From: Dmytro Prokopchuk <dmytro.prokopchuk@globallogic.com>
Date: Mon, 27 Apr 2020 20:07:42 +0300
Subject: [PATCH] Porting to kernel 5.4

Fixed following error:
Implicit declaration of function 'init_timer'
Caused by changing Timer API.

Signed-off-by: Dmytro Prokopchuk <dmytro.prokopchuk@globallogic.com>
Jira-ID: ADM-4734
Change-Id: I150ebc6fcea7ad5fb2f64099ce03893deb3a71d5
---
 src/lkm/uvcs_lkm_internal.h |  1 +
 src/lkm/uvcs_lkm_uf_io.c    | 50 ++++++++++++++++++-------------------
 2 files changed, 25 insertions(+), 26 deletions(-)

diff --git a/src/lkm/uvcs_lkm_internal.h b/src/lkm/uvcs_lkm_internal.h
index d3f3249..d074ed9 100644
--- a/src/lkm/uvcs_lkm_internal.h
+++ b/src/lkm/uvcs_lkm_internal.h
@@ -162,6 +162,7 @@ struct uvcs_vcp_hwinf {
 	u32						 iparch;
 	u32						 ipgroup;
 	bool					 irq_enable;
+	u32						 id;
 
 	struct platform_device	*pdev;
 	struct timer_list       timer_vlc;
diff --git a/src/lkm/uvcs_lkm_uf_io.c b/src/lkm/uvcs_lkm_uf_io.c
index 34bdb16..8e5a742 100644
--- a/src/lkm/uvcs_lkm_uf_io.c
+++ b/src/lkm/uvcs_lkm_uf_io.c
@@ -144,8 +144,8 @@ static const struct soc_device_attribute device_es2x[] = {
 /******************************************************************************/
 static irqreturn_t uvcs_vlc_int_handler(int irq, void *dev);
 static irqreturn_t uvcs_ce_int_handler(int irq, void *dev);
-static void uvcs_vlc_timer_handler(unsigned long data);
-static void uvcs_ce_timer_handler(unsigned long data);
+static void uvcs_vlc_timer_handler(struct timer_list *t);
+static void uvcs_ce_timer_handler(struct timer_list *t);
 
 static int uvcs_vcp_request_irq(struct platform_device *pdev);
 static void uvcs_vcp_free_irq(struct platform_device *pdev);
@@ -229,21 +229,21 @@ static irqreturn_t uvcs_ce_int_handler(
 /**
  * \brief Timer handler for VLC module (timeout VCP processing)
  */
-static void uvcs_vlc_timer_handler(
-	unsigned long data /**< [in] hardware identifier */
-	)
+static void uvcs_vlc_timer_handler(struct timer_list *t)
 {
+	struct uvcs_vcp_hwinf *vcpinf = from_timer(vcpinf, t, timer_vlc);
+
 	if (driver_info) {
 		struct timespec ts;
 		unsigned long flags;
 
 		getrawmonotonic(&ts);
-		if (data < driver_info->vcp_devnum) {
-			spin_lock_irqsave(&driver_info->vcpinf[data].slock_vlc, flags);
-			del_timer(&driver_info->vcpinf[data].timer_vlc);
-			iowrite32(0u, driver_info->vcpinf[data].reg_vlc + UVCS_VCPREG_IRQENB);
-			uvcs_cmn_vlc_interrupt(driver_info->uvcs_info, data, ts.tv_nsec, UVCS_TRUE);
-			spin_unlock_irqrestore(&driver_info->vcpinf[data].slock_vlc, flags);
+		if (vcpinf->id < driver_info->vcp_devnum) {
+			spin_lock_irqsave(&driver_info->vcpinf[vcpinf->id].slock_vlc, flags);
+			del_timer(&driver_info->vcpinf[vcpinf->id].timer_vlc);
+			iowrite32(0u, driver_info->vcpinf[vcpinf->id].reg_vlc + UVCS_VCPREG_IRQENB);
+			uvcs_cmn_vlc_interrupt(driver_info->uvcs_info, vcpinf->id, ts.tv_nsec, UVCS_TRUE);
+			spin_unlock_irqrestore(&driver_info->vcpinf[vcpinf->id].slock_vlc, flags);
 		}
 	}
 }
@@ -251,21 +251,21 @@ static void uvcs_vlc_timer_handler(
 /**
  * \brief Timer handler for CE module (timeout VCP processing)
  */
-static void uvcs_ce_timer_handler(
-	unsigned long data /**< [in] hardware identifier */
-	)
+static void uvcs_ce_timer_handler(struct timer_list *t)
 {
+	struct uvcs_vcp_hwinf *vcpinf = from_timer(vcpinf, t, timer_ce);
+
 	if (driver_info) {
 		struct timespec ts;
 		unsigned long flags;
 
 		getrawmonotonic(&ts);
-		if (data < driver_info->vcp_devnum) {
-			spin_lock_irqsave(&driver_info->vcpinf[data].slock_ce, flags);
-			del_timer(&driver_info->vcpinf[data].timer_ce);
-			iowrite32(0u, driver_info->vcpinf[data].reg_ce + UVCS_VCPREG_IRQENB);
-			uvcs_cmn_ce_interrupt(driver_info->uvcs_info, data, ts.tv_nsec, UVCS_TRUE);
-			spin_unlock_irqrestore(&driver_info->vcpinf[data].slock_ce, flags);
+		if (vcpinf->id < driver_info->vcp_devnum) {
+			spin_lock_irqsave(&driver_info->vcpinf[vcpinf->id].slock_ce, flags);
+			del_timer(&driver_info->vcpinf[vcpinf->id].timer_ce);
+			iowrite32(0u, driver_info->vcpinf[vcpinf->id].reg_ce + UVCS_VCPREG_IRQENB);
+			uvcs_cmn_ce_interrupt(driver_info->uvcs_info, vcpinf->id, ts.tv_nsec, UVCS_TRUE);
+			spin_unlock_irqrestore(&driver_info->vcpinf[vcpinf->id].slock_ce, flags);
 		}
 	}
 }
@@ -326,13 +326,11 @@ static void uvcs_hw_start(
 		/* set kernel timer */
 		if (hw_module_id == UVCS_CMN_BASE_ADDR_VLC) {
 			drv->vcpinf[hw_ip_id].timer_vlc.expires = jiffies + UVCS_TIMEOUT_TIMER;
-			drv->vcpinf[hw_ip_id].timer_vlc.data = hw_ip_id;
-			drv->vcpinf[hw_ip_id].timer_vlc.function = &uvcs_vlc_timer_handler;
+			drv->vcpinf[hw_ip_id].id = hw_ip_id;
 			add_timer(&drv->vcpinf[hw_ip_id].timer_vlc);
 		} else {
 			drv->vcpinf[hw_ip_id].timer_ce.expires = jiffies + UVCS_TIMEOUT_TIMER;
-			drv->vcpinf[hw_ip_id].timer_ce.data = hw_ip_id;
-			drv->vcpinf[hw_ip_id].timer_ce.function = &uvcs_ce_timer_handler;
+			drv->vcpinf[hw_ip_id].id = hw_ip_id;
 			add_timer(&drv->vcpinf[hw_ip_id].timer_ce);
 		}
 	}
@@ -736,8 +734,8 @@ static int uvcs_vcp_request_irq(
 		goto err_exit_2;
 	}
 
-	init_timer(&vcpinf->timer_vlc);
-	init_timer(&vcpinf->timer_ce);
+	timer_setup(&vcpinf->timer_vlc, uvcs_vlc_timer_handler, 0);
+	timer_setup(&vcpinf->timer_ce, uvcs_ce_timer_handler, 0);
 	spin_lock_init(&vcpinf->slock_vlc);
 	spin_lock_init(&vcpinf->slock_ce);
 	vcpinf->irq_enable = true;
-- 
2.28.0

